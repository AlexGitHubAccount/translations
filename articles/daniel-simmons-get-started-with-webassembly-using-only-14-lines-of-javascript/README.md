# Начало работы с WebAssembly, используя только 14 строк на JavaScript
![](https://cdn-images-1.medium.com/max/2000/1*sHlMI2kxKBlm76U2Gmt2Cw.jpeg)

*Перевод статьи [Daniel Simmons](https://medium.freecodecamp.org/@dsimmons_23530): [Get started with WebAssembly — using only 14 lines of JavaScript](https://medium.freecodecamp.org/get-started-with-webassembly-using-only-14-lines-of-javascript-b37b6aaca1e4).*

[WebAssembly — это новая веб-технология](https://www.youtube.com/watch?v=6v4E6oksar0&t=241s) с огромным потенциалом. Она окажет существенное влияние на то, как веб-приложения будут разрабатываться в будущем.

Но иногда мне кажется, что эта технология просто не хочет, чтобы люди её поняли... Можно сказать, даже в странной пассивно-агрессивной манере.

Когда я смотрю документацию или обучающие материалы, которых уже целая куча, то не могу не чувствовать себя фермером, который молил о дожде, чтобы потом утонуть в потопе. Технически я получил то, что хотел... просто не так, как надеялся. "Ты хочешь дождь?! О, я дам тебе дождь!"

Так происходит потому, что WebAssembly даёт очень много новых возможностей, которые могут быть реализованы множеством разных способов. Но он настолько сильно изменился по пути к официальному MVP в феврале, что когда вы впервые узнаете о нём, то легко можете утонуть в море деталей.

В продолжение метафоры дождя, эта статья — моя попытка предоставить лёгкий душ из введения в WebAssembly. Никакой концепции или болтов и гаек, а фактическая реализация скрипта с использованием этой технологии.

Я покажу вам несколько шагов для реализации простого проекта, исключая сложность, где это возможно. После того как вы реализуете простейший проект с WebAssembly хотя бы раз, многие из идей более высокого уровня станут гораздо проще для понимания.

## Давайте разобьём на части

Всё станет намного понятнее, если мы сделаем шаг назад и рассмотрим список действий для внедрения WebAssembly в проект.

При первом взгляде на WebAssembly он может показаться просто большим комком опций и процессов. Разделение его на отдельные шаги поможет нам сформировать чёткое представление о том, что происходит:

1. **написание:** напишите что-нибудь (или возьмите существующий проект) на C, C++ или Rust;
2. **компиляция:** скомпилируйте этот код в WebAssembly (это даст вам бинарный .wasm файл);
3. **подключение:** перенесите .wasm файл в проект;
4. **инициализация:** напишите на JavaScript немного асинхронного кода, который скомпилирует и инициализирует .wasm файл так, чтобы с ним можно было взаимодействовать.

В целом, это всё. Само собой, есть разные реализации этого процесса, но в этом и суть.

В общем случае это не так уж сложно, но, тем не менее, *может* быть чрезвычайно трудным, поскольку большинство шагов допускает разную степень сложности. Во всяком случае, я собираюсь сделать всё на самом базовом уровне, чтобы избежать ошибок.

Для нашего проекта мы будем писать простую функцию на C++ (не беспокойтесь, если вы не знакомы с этим языком, код будет *максимально* простым). Функция будет возвращать квадрат заданного числа.

Затем мы скомпилируем это в .wasm с помощью онлайн-компилятора (вам не понадобится скачивать или использовать командную строку). Далее мы инициализируем эту функцию с помощью 14 строк кода на JavaScript.

Когда мы закончим, вы сможете вызвать функцию, написанную на C++ так, как если бы она была JavaScript-функцией, и вы будете поражены!

Огромное количество возможностей, которые открывает WebAssembly, просто взрывает мозг.

## Написание

Давайте начнём с нашего кода на C++. Помните, что мы не будем использовать локальное окружение для написания или компиляции кода.

Вместо этого мы будем использовать онлайн-инструмент, который называется [WebAssembly Explorer](https://mbebenita.github.io/WasmExplorer/). Он похож на CodePen для WebAssembly и позволяет скомпилировать ваш код на C или C++ прямо в браузере и скачать .wasm файл.

После того как вы открыли WebAssembly Explorer, введите этот код на C++ в самое левое окно:

```
int squarer(int num) {
  return num * num;
}
```

Как я и говорил, мы используем очень простой пример. Даже если вы никогда раньше не видели C или C++, то всё равно не сложно догадаться, что здесь происходит.

## Компиляция

Далее кликните по кнопке `compile` на красной панели над вашим C++ кодом. Вот что вы увидите:

![](https://cdn-images-1.medium.com/max/1000/1*KAAS0TC2K5c2xkBiaWNNjg.png)

Средняя колонка содержит человеко-читаемую версию бинарного файла .wasm, которую вы только что создали. Это называется "WAT", или [WebAssembly Text Format](https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format).

Справа — получившийся ассемблерный код. Довольно круто.

Я не буду разбирать результат компиляции подробно, но вы должны знать хотя бы немного о WAT-файле, чтобы двигаться дальше.

WAT существует потому, что мы, люди, обычно испытываем трудности с пониманием чистого двоичного кода. Это, по сути, слой абстракции, который помогает понимать WebAssembly-код и взаимодействовать с ним.

В нашем случае мы хотим понять, как WebAssembly ссылается на функцию, которую мы только что создали. Это нужно для того, чтобы узнать точное имя, на которое мы будем ссылаться в JavaScript-файле позже.

Любые функции, которые вы написали на C++, будут доступны в WebAssembly как нечто называемое `export`. Мы поговорим об этом немного позже, ну а сейчас вам нужно знать лишь то, что `export` — это то, с чем можно взаимодействовать.

Взгляните на WAT-файл и найдите там слово `export`. Вы увидите его дважды: в первый раз рядом со словом `memory` и затем снова рядом со словом `_Z7squareri`. О `memory` пока не обязательно ничего знать, а вот `_Z7squareri` нас определённо интересует.

В коде на C++ мы назвали функцию `squarer`, но теперь она почему-то называется `_Z7squareri`. В первый раз это может сбить с толку.

Насколько я могу судить, префикс "_Z7" и суффикс "i" — это [отладочные маркеры](https://docs.microsoft.com/en-us/cpp/build/reference/z7-zi-zi-debug-information-format), добавленные C++ компилятором. В это не обязательно глубоко вникать. Вам просто нужно знать, что это произойдет, т.к. вам понадобится точное имя в JavaScript-файле, чтобы вызвать функцию, написанную на C++.

## Подключение

Теперь просто нажмите на кнопку "download" в фиолетовой секции. Вы должны получить бинарный .wasm файл. Переименуйте его в `squarer.wasm`. Затем создайте новую папку и переместите туда файл `squarer.wasm` вместе с двумя другими файлами:

* `index.html` (шаблонный код),
* `scripts.js` (пока что пустой).

## Инициализация

Теперь сложная часть. Или, по крайней мере, часть, которая ввела меня в замешательство, когда я в первый раз начал просеивать документацию.

Хотя, в конечном итоге, вы сможете подключать .wasm модули, как старые добрые ES6 модули (используя `<script type='module'>`), пока что вам нужно научиться подключать "вручную". Это делается путём создания асинхронных вызовов WebAssembly API, вот три шага:

* загрузите ваш бинарный .wasm файл в **буфер массива***;
* скомпилируйте бинарные данные в **модуль WebAssembly***;
* **инициализируйте** модуль WebAssembly;

Если вы поняли, о чём идёт речь, то можете пропустить следующую часть. Но если вы обнаружили себя почёсывающим голову и хотите получить подробное объяснение, то продолжайте читать.

- - - -

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*