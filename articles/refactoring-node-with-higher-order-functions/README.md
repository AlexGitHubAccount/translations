# Рефакторинг в NodeJS с помощью функций высшего порядка

*Перевод статьи [Sean May](https://blog.rangle.io/author/sean-may/): [Refactoring Node with Higher-Order Functions](https://blog.rangle.io/refactoring-node-with-higher-order-functions/).*

![](https://blog.rangle.io/content/images/2017/02/rangleio-refactoring-node-with-higher-order-functions.gif)

До праздничных дней мой коллега [Ник](http://blog.rangle.io/author/nicholas/) написал отменную статью о том, [как можно улучшить навыки функционального программирования, выйдя из зоны комфорта](https://blog.rangle.io/get-better-at-functional-javascript-without-learning-more-javascript/). Он написал том, как горят корабли у берегов новых и неизведанных языков, и если вы уже нашли свое призвание в завоевании таких земель как Erlang, Elm, Haskell или в покорении островов Akka/Scala, то я снимаю перед вами шляпу.

Но на этот раз я хотел бы, чтобы наша баталия перенеслась поближе к дому, где я бы показал вам, как использовать функции высшего порядка для устранения одного из наиболее известных полей битвы в JavaScript: функции обратного вызова и маршрутизация в NodeJS-фрейморках (например, таких как Express и ему подобные).

Теперь давайте представим на мгновение, что мы имеем дело с очень простым описанием маршрутизации, которое возвращает статически заданный файл по запросу

https://gist.github.com/ufocoder/30ee6c335b4d4e2debce3f2fe57a3b81

Согласитесь, что это не такое уж и громадное количество кода, с которым нам приходится иметь дело, плюс этот код не такой плохой, каким он мог бы быть.

Существуют десятки (возможно даже сотни) библиотек, на которые мы можем опереться, чтобы писать как можно меньше кода. Но если посмотреть на исходный код этих библиотек, то окажется, что на самом деле его там не так много.

Более того, у нас есть вложенная маршрутизация, где мы можем использовать `Promise` во вложенных маршрутах, а это сразу усложняет некоторые вещи.

Я обычный поклонник [дяди Боба](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D1%82%D0%B8%D0%BD,_%D0%A0%D0%BE%D0%B1%D0%B5%D1%80%D1%82), и здесь его предложение, возможно, заключалось бы в том, чтобы разделить код на блоки по их назначению. Один блок кода контролировал бы ответ на запрос, а другой бы контролировал бизнес логику.

Эти меры могут показаться несколько превентивными, но код в JS должен быть небольшим и удобным для чтения.

https://gist.github.com/ufocoder/1d7927cc638ae88a01a0159a1b8f3246

На текущий момент мы зашли так далеко как смогли. Мы выделили блоки кода из общей логики. Но цель в первую очередь состоит в том, чтобы предпринять эти предохранительные меры.

Пусть, это будет выглядеть несколько предупредительно, но существуют сильные аргументы в пользу этого:  после того как мы изолируем проблемные места кода друг от друга, они могут быть реорганизованы для повторного использования (а не просто разбитие алгоритма на последовательные блоки, давайте не будем заставлять дядю Боба плакать).

С другой стороны, что этот подход быстро станет шаблоном разработки, вот увидите.

https://gist.github.com/ufocoder/83ed01863d9d2f30822900d8ed80f602

Это намного меньше того, что могло бы получиться на языке Java, но, тем не менее, получилось именно так. Однако, все три функции по-прежнему ужасны, потому что их необходимо держать внутри маршрутизации.

https://gist.github.com/ufocoder/dcc92642a1f70013aa1b0c6618de8ab3

Поскольку функции сильно связаны друг с другом, этот шаблон пригоден для каких-то единичных случаев, но он по-прежнему не пригоден для тестирования или переиспользования. Это не внушает особого оптимизма, потому что, даже если наш код стал капельку чище, у нас по прежнему останется много вещей, скрытых внутри этого маршрута.

Но у нас есть секретное оружие в JavaScript, да и в целом в функциональных языках. До сих пор нам было больно, но существует инструмент, который мы просто не понимали до этого момента.

## Функции высших порядков

*Функция высокого порядка* - это функция, которая принимает другую функцию в качестве аргумента, или это функция, которая будет возвращать в результате другую функцию (или и то, и другое).

В большинстве языков, даже если вы можете вернуть функцию из функции, это не принесет вам много пользы. Но в большинстве функциональных языков, благодаря концепции лексической области видимости, у нас есть возможность использования `замыканий`.

На самом деле вы использовали его все время, в функции обратного вызова для маршрутизации и в функции обратного вызова для `readFile`.

Теперь мы можем перейти на следующий уровень, чтобы сделать этот код более чистым и простым в тестировании. Во-первых, нам нужно убедиться, что мы понимаем. с чем мы имеем дело, и мы понимаем наш желаемый результат.

https://gist.github.com/ufocoder/19747dde65cf409b2e355a1ed442a4f2

Задумайтесь над этим. Сначала мы передаем значение `x`, а после возвращаем обратно функцию. Но зачем это делать?

https://gist.github.com/ufocoder/7c2977d02d25f76b2ace74daae8a7b96

Обратите внимание, что значение `x` внутри функции защищено от изменения значения `x` за ее приделами. Это потому, что `х`, на который мы ссылаемся, является тем, который виден во время создания функции, а не в то время, когда функция **вызывается**. Таким образом, передавая эту вновь созданную функцию обратно во внешний мир, мы запоминаем значение, которое передавалось как аргумент.

https://gist.github.com/ufocoder/4e34ba6ebccd3eae8335581efa5338c8

Вся сила функций этого типа заключается в сохранении переданных значений, и дальнейшей передачи "настроенных" функций в различные места в коде.

Для использования ссылок на конфигурацию существует много возможностей для использования этих типов функций, но передайте функцию, которая будет использоваться в нескольких местах.

Зная это, мы должны иметь возможность найти способ создания функции, которая содержит некоторую информацию, и возвращает предварительно сконфигурированную функцию, готовую к использованию для чего-то другого/чем-то другим.

https://gist.github.com/ufocoder/08c7b289d0e0c856bb3ab6f57c6c19c0

Если вы посмотрите на возвращаемую функцию, то станет ясно, что она делает. То есть, теперь она занимается тем то, что раньше делала функция `nodeCallback`.

Внешняя функция имеет функцию обратного вызова для обработки успешного и ошибочного поведения.

It’s configuring that instance of the inner function to refer to those things, so that when the returned function is called, it can still access them, the same way `rememberX` worked.

Она конфигурирует этот экземпляр внутренней функции, чтобы ссылаться на эти вещи, поэтому, когда вызываемая функция вызывается, она все равно может обращаться к ним, так же, как и `rememberX`.

https://gist.github.com/ufocoder/2cd3537aa80a57f550819ac0749e71b6

Мы успешно удалили ранее созданый шаблон кода, подставив его в настраиваемую функцию высшего порядка. Если бы мы хотели сделать пойти еще дальше, то мы бы создали аналогичные функции для создания успешных и обработчиков ошибок.

https://gist.github.com/ufocoder/012d0cbdccf4dfea9407544fc30e14b2

Наша логика маршрутизации теперь очень чиста, и стало довольно очевидно, как все работает, когда мы уловили, что и почему.

Если же вашей команде будет комфортней (приятней) использовать подход функционального программирования, то возможно, вместо предыдущего варианта, код выглядел бы так:

https://gist.github.com/ufocoder/4c65d2c64dfb7ee9e73f31c8f567f0b1

Конечно, вам не нужно писать свой JavaScript-код, похожим на LISP, но если это работает для вашей команды…

Этот подход имеет некоторые забавные особенности. Не принимая ничего из внешнего мира, кроме того что передается явный образом, мы создаем самодостаточный код:

- Тестирование

https://gist.github.com/ufocoder/cf881d7548f8ea54740ec8ebf18838dc

- Переиспользование

https://gist.github.com/ufocoder/056973240534441a70b5a647cd0c7a49

- Почти что SOLID

Да, хорошо. Дядя Боб никогда не подразумевал, чтобы его принципы применимы к функциональному программированию, и он бы почувствовал здесь себя почти что обманутым, потому что большая часть нашего пути оказалось довольно просто… и мы даже не использовали наследование, более того, в этом не будет никакой необходимости и для оставшегося пути к нашей цели.

Конечно, это не конец. Вы можете с радостью использовать свои "сконфигурированные" функции внутри других функций высшего порядка.

https://gist.github.com/ufocoder/904a3504d55caf0e3fb8dc5a970fd11f

> «Но почему я должен использовать этот подход, когда есть десятки библиотек, которые могут сделать это за меня?»

Реальность такова, что библиотеки действительно делают код более чистым и упрощают разработку. И если они у вас уже есть и они делают ваше жизнь проще, то продолжайте использовать их.

Тем не менее, если бы была библиотека для решения каждой проблемы, и библиотека, чтобы связать все библиотеки вместе, чтобы повысить ценность бизнеса, тогда у нас, вероятно, не было бы работы.

Этот подход можно применять на любом уровне и он особенно хорош для разделения кода, который сохраняет его ценность, что поддерживает работу системы.

https://gist.github.com/ufocoder/95f27e3a70abcc519430a2c5c55bc289

Существуют даже методы для создания этих "конфигурируемых" функций автоматически: «Частичное применение» и «Каррирование». Но об этом как-нибудь в другой раз.

- - - -

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

[Статья на GitHub](https://github.com/devSchacht/translations/tree/master/./articles/refactoring-node-with-higher-order-functions/README.md)
