# Что и как тестировать с помощью Jest и Enzyme. Полная инструкция по тестированию React компонентов

*Перевод статьи [Alona Pysarenko](https://djangostars.com/blog/author/alona-pysarenko/): [What and How to Test with Jest and Enzyme. Full Instruction on React Components Testing](https://djangostars.com/blog/what-and-how-to-test-with-enzyme-and-jest-full-instruction-on-react-component-testing/).*

Тестирование React компонентов может оказаться сложной задачей как для начинающих, так и для опытных разработчиков, которые уже работали с тестами. Вам может быть интересно сравнить ваши собственные подходы с теми, которые мы используем в нашем проекте. Для покрытия кодовой базы вам необходимо знать, какие компоненты должны быть протестированны и какой код точно должен быть покрыт тестами.

Во время чтения я расскажу о следующих темах:

* Определение правильного порядка тестирования компонентов на основе структуры проекта
* Нахождение того, что можно опустить в покрытии тестами (что можно не тестировать)
* Выявление необходимости использовать тестирование на основе снимков
* Определение, что тестировать в компоненте и в каком порядке
* Предоставление подробных примеров кода

Статься требует, чтобы читатель уже знал о Jest и Enzyme. Информацию об установке и настройке можно легко найти в интернете или на официальных сайтах.

Представим следующую ситуацию: вам нужно покрыть кодовую базу проекта тестами, и так с чего вам начать и что вы должны получить в конце тестирования? 100%-ое покрытие тестами? Это показатель, к которому вы должны стремиться, но в большинстве случаев вы его не получите. Почему? Потому что вы не должны тестировать весь код. Мы выясним, почему и что следует оставить без тестов. Более того, 100%-ое покрытие не всегда гарантирует, что компонент будет полностью протестирован. Также, нет никакой гарантии, что он сообщит вам если что-то было изменено. Не стремитесь к процентам, избегайте написания фальшивых тестов и старайтесь не потерять основные детали компонента.

## Определение правильного порядка тестирования компонентов на основе структуры проекта

Давайте обсудим этот вопрос на следующей части структуры проекта:

![](./images/img-1.png)

Я взяла каталог `shared`, потому что он очень важен; он состоит из компонентов, которые используются на нескольких разных страницах проекта. Они переиспользуемые и обычно маленькие и не сложные. Но если тот или иной компонент выйдет из строя, это приведёт к сбою в других местах. Поэтому мы должны быть уверены, что они написаны правильно. Структура этого каталога разделена на несколько папок, каждая из которых содержит компоненты.

![](./images/img-2.png)

Как определить правильный порядок тестирования компонентов в общем каталоге:

* Всегда следуйте правилу от простого к сложному. Проанализируйте каждый каталог и определите, какие компонентыявляются независимыми, т.е. их рендеринг не зависит от других компонентов; они самодостаточны и могут использоваться отдельно как единое целое. Из структуры выше, это каталоги `inputs` в папке `forms`. Он содержит компоненты ввода в `redux-forms`, такие как `TextInput`, `SelectInput`, `CheckboxInput`, `DateInput` и др.
* Затем мне нужно определить вспомогательные компоненты, которые часто используются в `inputs` компонентах, но их следует проверять отдельно. Это каталог `utils`. Компоненты в этой папке не сложные, но очень важные. Они часто переиспользуются и помогают с повторяющимися действиями
* Следующий шаг - определить, какие компоненты можно использовать независимо друг от друга. Если такие есть, возьмите их для тестирования. В нашей структуре - это `widgets`, небольшие компоненты с простой функциональностью. Они будут третьим пунктом в очереди на тестирование
* Далее проанализируйте остальные каталоги и определите более сложные компоненты, которые можно использовать независимо или в сочетании с другими компонентами. В нашем случае - это каталог `modals`, эти компоненты будут подробнее описаны ниже
* Самые сложные для тестирования компоненты останутся в конце. Это каталог `hoc` и `fields` из папка `forms`. Как вам определить, какой из них следует тестировать первым? Я беру каталог, компоненты которого уже встречались в тестируемых компонентах. Например, компоненты из `hoc` каталога присутствовали в компоненте `widgets`, поэтому я уже знаю, где и с какой целью используется этот каталог и его компоненты
* Последняя папка `fields` содержит компоненты связанные с `redux-forms`

Окончательный порядок компонентов (на основе нашего примера) будет выглядеть следующим образом:

![](./images/img-3.png)

Следуя этому порядку, вы постепенно увеличиваете сложность тестируемых компонентов, таким образом, когда дело доходит до работы с более сложными компонентами, вы уже знаете, как ведут себя самые маленькие. Не берите для тестирования, например, поле «массив» если вы не знаете, как проверить поле «текст»; не берите компонент с использованием `redux-forms`, если вы не тестировали само поле «форма». Будьте последовательны в своем выборе, не берите первый компонент, который приходит в голову и включите логику. Конечно, структура вашего проекта может отличаться; он может иметь другие имена каталогов или содержать дополнительные компоненты, действия или редьюсеры, но логика определения порядка тестирования компонентов одинаковая.

**Давайте определим, что следует пропустить при тестировании:**

1. **Сторонние библиотеки**. Не тестируйте функции, взятые из другой библиотеки; вы не несете ответственности за этот код. Пропустите его или имитируйте выполнение, если это нужно для тестирования вашего кода.
2. **Константы**. Название говорит само за себя. Они не изменчивы; это набор статического кода, который не предназначен для изменения.
3. **Встроенные стили** (если они используются в компоненте). Чтобы проверить встроенные стили, необходимо дублировать объект со стилями в тесте; если изменяется объект стилей, необходимо также изменить его в тесте. Не дублируйте код компонента в тестах, вы можете забыть изменить его в тестах. Более того, ваш коллега никогда не догадается о дублировании. В большинстве случаев встроенные стили не изменяют поведение компонента следовательно они не нуждаются в проверке. Возможно исключение, если ваши стили изменяются динамически.
4. **Вещи, не связанные с тестируемым компонентом**. Пропустите покрытие тестами компоненты которые были импортированны, будьте осторожны, если один компонент обернут в другой. В таком случае не тестируйте оболочку, анализируйте и тестируйте все отдельно.

Итак, как вы на самом деле пишете тесты? Я объединяю два подхода к тестированию:

* Тестирование при помощи снимков
* Тестирование логики компонентов

Тестирование при помощи снимков (Snapshot-тестирование) - полезный инструмент тестирования, если вы хотите быть уверенным, что пользовательский интерфейс не изменился. Когда вы впервые сталкиваетесь с этим инструментом тестирования, возникают вопросы, связанные с организацией и управлением снимками (snapshots). Принцип работы очень прост, но, к сожалению, он нигде подробно не описан; на официальном сайте [jestjs.io](https://jestjs.io/), очень плохо описана работа с тестирование при помощи снимков.

## Как тестировать при помощи снимков

**Шаг 1**. Напишите тест для компонента и в функции `expect` используйте метод `.toMatchSnapshot()`, который создаст вам снимок.

```js
it('render correctly text component', () => {  
    const TextInputComponent = renderer.create(<TextInput />).toJSON();
    expect(TextInputComponent).toMatchSnapshot();
});
```

**Шаг 2**. При первом запуске теста на одном уровне с тестом будет создан каталог с именем `__snapshots__` с автоматически созданным файлом с расширением `.snap` внутри.

Снимок выглядит так:

```js
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Render TextInput correctly component 1`] = `  
<input  
  className="input-custom"
  disabled={undefined}
  id={undefined}
  name={undefined}
  onBlur={undefined}
  onChange={[Function]}
  pattern={undefined}
  placeholder={undefined}
  readOnly={false}
  required={undefined}
  type="text"
  value={undefined}
/>
`;
```

**Шаг 3**. Отправьте снимок в репозиторий и сохраните его вместе с тестом.

Если компонент был изменен, то вам нужно обновить снимок с флагом `--updateSnapshot` или использовать короткий флаг `u`.

## Снимок создан; как это работает?

Рассмотрим два случая:

### 1. Компонент изменился

* Запускаем тестирование
* Создается новый снимок, который сранивается с ранее созданным снимком, хранящимся в каталоге `__snapshots__`
* Не удалось выполнить тест, так как снимок отличается

![](./images/img-4.gif)

### 2.  Компонент не изменился

* Запускаем тестирование
* Создается новый снимок, который сранивается с ранее созданным снимком, хранящимся в каталоге `__snapshots__`
* Тест пройден, так как снимки идентичны

![](./images/img-5.gif)

Все нормально, когда я тестирую небольшие компоненты без логики, просто UI рендеринг, но, как показывает практика, на реальных проектах таких компонентов нет. А если они есть, то совсем в небольшом количестве.

Достаточно ли снимков для полного тестирования компонентов?

## Основные инструкции по тестирования компонентов

1. **Один компонент должен иметь один снимок**. Если один снимок завершается неудачей, скорее всего, остальные тоже потерпят неудачу, поэтому не создавайте и не храните кучу ненужных снимков, забивающих пространство и запутывающих разработчиков, которые будут читать ваши тесты после вас. Конечно, бывают исключения, когда необходимо проверить поведение компонента в двух состояниях, например, в компонент в состоянии перед открытием всплывающего окна и после открытия. Однако даже такой вариант можно заменить на такой: первый тест сохраняет снимок с состоянием компонента по умолчанию, без всплывающего окна, а второй тест имитирует событие и проверяет наличие определенного класса.
Таким образом, вы можете легко обойти создание нескольких снимков.

2. **Тестирование свойств**. Как правило, тестирование свойств я разделяю на два шага. - Во-первых, проверьте значение свойств по умолчанию; когда компонент рендерится, я ожидаю, что значение будет равно `defaultProps` если оно определенно. - Во-вторых, я проверяю пользлвательские свойства; я устанавливаю свое собственное значение и ожидаю, что оно будет получено после рендера компонента.

3. **Тестирование типов данных**. Чтобы проверить, какой тип данных приходит в свойства или какие данные получены после определенных действий, я использую специальную библиотеку `jest-extended` (Дополнительный вычислители Jest) которая имеет расширенный набор вычислителей, которые отсутствуют в `Jest`. С помощью этой библиотеки тестировать типы данных намного проще и приятнее. Тестирование `PropTypes` - спорный вопрос. Некоторые разработчики могу возразить против тестирования `PropTypes`, потому что это сторонний пакет и не должен тестироваться, но я настаиваю на тестировании `PropTypes` компонентов, потому что я не тестирую саму функциональность пакета, я просто гарантирую, что `PropTypes` верны. Тип данных является очень важной частью программирования и не должен игнорироваться.

4. **Тестирование событий**. После создания снимков и покрытия свойств тестами можно быть уверенным в корректном рендеринге компонента, но этого недостаточно для полного покрытия при наличии событий в компоненте. Вы можете проверить события несколькими способами; наиболее широко используемые:

* создаете фиктивное событие => имитируете событие => ожидаете вызов события
* создаете фиктивное событие => имитируете событие с передачей необходимых параметров => рендерите компонент => ожидаете вызов события с передаваемыми параметрами
* передаете необходимые свойства => рендерите компонент => имитируете событие => ожидаете вызов события с передаваемыми параметрами

5. **Тестирование условий**. Очень часто у вас могут быть условия для вывода определенного класса, рендеринга определенного раздела кода, передачи необходимых свойств и т.д. Не забывайте об этом, потому что со значениями по умолчанию будет пройдена только одна ветка, а вторая останется непроверенной. Так в сложных компонента с вычислениями и множественными условиями можно пропустить несколько веток. Чтобы убедиться, что все части кода покрыты тестами используйте инструменты покрытия и визуально проверяйте, какие ветки покрыты, а какие нет.

6. **Тестирование состояний**. Для проверки состояния в большинстве случаев необходимо написать два теста:

* Первый проверяет текущее состояние
* Второй проверяет состояние после вызова события. Рендерите компонент => вызываете функцию непосредственно в тесте => проверяете, как изменилось состояние. Чтобы вызывать функцию компонента, вам необходимо получить экземпляр компонента и только после этого вызывать его методы (пример показан в следующем тесте).

После того, как вы пройдете через этот список инструкций, ваш компонент будет покрыт тестами от 90% до 100%. Я оставила 10% для особых случаев, которые не были описаны в статье, но могут встретиться в коде.

## Пример тестирования

Давайте перейдем к примерам и шаг за шагом покроем компоненты с помощью тестов, описанных выше.

### 1. Тестирование компонента из `forms/inputs`

Возьмем один компонент из `forms/inputs`; пусть это будет компонент `DateInput.js` для выбора даты.

![](./images/img-6.gif)

Компонент `DateInput` использует библиотеку `react-datepicker`, с двумя утилитами: `valueToDate` (преобразует значение в дату) и `dateToValue` - это метод для манипулирования датой и `PropTypes` для проверки свойств React.

По коду компонента мы видим список свойств по умолчанию, с помощью которых компонент должен быть отрисован:

```js
const defaultProps = {  
    inputClassName: 'input-custom',
    monthsShown: 1,
    dateFormat: 'DD.MM.YYYY',
    showMonthYearsDropdowns: false,
    minDate: moment()
};
```

Все свойства подходят для создания снимков, за исключением одного `minDate: moment()`, moment() - будет давать нам текущую дату каждый раз, когда мы запускаем тест, и тест на основе снимков будет терпеть неудачу, потому что будет хранить устаревшую дату. Решение состоит в том, чтобы создать фиктивное значение:

```js
const defaultProps = {  
    minDate: moment(0)
}
```

`minDate` - это свойство, которое мне нужно в каждом визуальном компоненте; чтобы избежать дублирования, я создаю `HOC`, который получит `defaultProps` и возвращает компонент:

```js
import TestDateInput from '../DateInput';  
const DateInput = (props) =>  
    <TestDateInput
        {...defaultProps}
        {...props}
    />;
```

Не забывайте о `moment-timezone`, особенно если ваши тесты будут выполняться разработчиками из других стран в другом часовом поясе. Они будут получать фиктивные значения, но со сдвигом часового пояса. Решение - установить часовой пояс по умолчанию:

```js
const moment = require.requireActual('moment-timezone').tz.setDefault('America/Los_Angeles')  
```

Теперь компонент ввода даты готов к тестированию:

**1. Создайте снимок:**

```js
it('render correctly date component', () => {  
    const DateInputComponent = renderer.create(<DateInput />).toJSON();
    expect(DateInputComponent).toMatchSnapshot();
});
```

**2. Тестирование свойств:**

Посмотрите свойства и найдите самый важные; первое свойство для тестирования - `showMonthYearsDropdowns`, если оно установлено в `true`, отображается раскрывающийся список для полей месяц и год:

```js
it('check month and years dropdowns displayed', () => {  
    const props = {
            showMonthYearsDropdowns: true
        },
        DateInputComponent = mount(<DateInput {...props} />).find('.datepicker');
    expect(DateInputComponent.hasClass('react-datepicker-hide-month')).toEqual(true);
});
```

Проверим свойство `value` на `null`; эта проверка необходима для обеспечения отображения компонента без опредленного значения:

```js
it('render date input correctly with null value', () => {  
    const props = {
            value: null
        },
        DateInputComponent = mount(<DateInput {...props} />);
    expect((DateInputComponent).prop('value')).toEqual(null);
});
```

**3. Тестирование значения `PropTypes`, дата ожидается как строка:**

```js
it('check the type of value', () => {  
    const props = {
            value: '10.03.2018'
        },
        DateInputComponent = mount(<DateInput {...props} />);
    expect(DateInputComponent.prop('value')).toBeString();
});
```

**4. Тестирование событий:**

**4.1** Проверим событие `onChange`, для этого создадим фиктивное событие `onChange` => рендерим компонент ввода даты => имитируем событие изменения даты с новыми значениями => и, наконец, проверим что событие `onChange` было вызвано с новым значением.

```js
it('check the onChange callback', () => {  
    const onChange = jest.fn(),
        props = {
            value: '20.01.2018',
            onChange
        },
        DateInputComponent = mount(<DateInput {...props} />).find('input');
    DateInputComponent.simulate('change', { target: {value: moment('2018-01-22')} });
    expect(onChange).toHaveBeenCalledWith('22.01.2018');
});
```

**4.2** Убедимся, что всплывающее окно открывается после нажатия на поле с вводом даты, для этого найдем поле с вводом даты => имитируем событие клик => и проверим на наличие всплывающего окна с классом `.react-datepicker`.

```js
it('check DatePicker popup open', () => {  
    const DateComponent = mount(<DateInput />),
        dateInput = DateComponent.find("input[type='text']");
    dateInput.simulate('click');
    expect(DateComponent.find('.react-datepicker')).toHaveLength(1);
});
```

Полный список тестов: [DateInput.test.js](https://github.com/ned-alyona/testing-jest-enzyme/blob/master/shared/forms/inputs/__tests__/DateInput.test.js)



- - - -

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*