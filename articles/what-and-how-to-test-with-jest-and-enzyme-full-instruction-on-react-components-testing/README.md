# Что и как тестировать с помощью Jest и Enzyme. Полная инструкция по тестированию React компонентов

*Перевод статьи [Alona Pysarenko](https://djangostars.com/blog/author/alona-pysarenko/): [What and How to Test with Jest and Enzyme. Full Instruction on React Components Testing](https://djangostars.com/blog/what-and-how-to-test-with-enzyme-and-jest-full-instruction-on-react-component-testing/).*

Тестирование React компонентов может оказаться сложной задачей как для начинающих, так и для опытных разработчиков, которые уже работали с тестами. Вам может быть интересно сравнить ваши собственные подходы с теми, которые мы используем в нашем проекте. Для покрытия кодовой базы вам необходимо знать, какие компоненты должны быть протестированны и какой код точно должен быть покрыт тестами.

Во время чтения я расскажу о следующих темах:

* Определение правильного порядка тестирования компонентов на основе структуры проекта
* Нахождение того, что можно опустить в покрытии тестами (что можно не тестировать)
* Выявление необходимости использовать тестирование на основе снимков
* Определение, что тестировать в компоненте и в каком порядке
* Предоставление подробных примеров кода

Статься требует, чтобы читатель уже знал о Jest и Enzyme. Информацию об установке и настройке можно легко найти в интернете или на официальных сайтах.

Представим следующую ситуацию: вам нужно покрыть кодовую базу проекта тестами, и так с чего вам начать и что вы должны получить в конце тестирования? 100%-ое покрытие тестами? Это показатель, к которому вы должны стремиться, но в большинстве случаев вы его не получите. Почему? Потому что вы не должны тестировать весь код. Мы выясним, почему и что следует оставить без тестов. Более того, 100%-ое покрытие не всегда гарантирует, что компонент будет полностью протестирован. Также, нет никакой гарантии, что он сообщит вам если что-то было изменено. Не стремитесь к процентам, избегайте написания фальшивых тестов и старайтесь не потерять основные детали компонента.

## Определение правильного порядка тестирования компонентов на основе структуры проекта

Давайте обсудим этот вопрос на следующей части структуры проекта:

![](./images/img-1.png)

Я взяла каталог `shared`, потому что он очень важен; он состоит из компонентов, которые используются на нескольких разных страницах проекта. Они переиспользуемые и обычно маленькие и не сложные. Но если тот или иной компонент выйдет из строя, это приведёт к сбою в других местах. Поэтому мы должны быть уверены, что они написаны правильно. Структура этого каталога разделена на несколько папок, каждая из которых содержит компоненты.

![](./images/img-2.png)

Как определить правильный порядок тестирования компонентов в общем каталоге:

* Всегда следуйте правилу от простого к сложному. Проанализируйте каждый каталог и определите, какие компонентыявляются независимыми, т.е. их рендеринг не зависит от других компонентов; они самодостаточны и могут использоваться отдельно как единое целое. Из структуры выше, это каталоги `inputs` в папке `forms`. Он содержит компоненты ввода в `redux-forms`, такие как `TextInput`, `SelectInput`, `CheckboxInput`, `DateInput` и др.
* Затем мне нужно определить вспомогательные компоненты, которые часто используются в `inputs` компонентах, но их следует проверять отдельно. Это каталог `utils`. Компоненты в этой папке не сложные, но очень важные. Они часто переиспользуются и помогают с повторяющимися действиями
* Следующий шаг - определить, какие компоненты можно использовать независимо друг от друга. Если такие есть, возьмите их для тестирования. В нашей структуре - это `widgets`, небольшие компоненты с простой функциональностью. Они будут третьим пунктом в очереди на тестирование
* Далее проанализируйте остальные каталоги и определите более сложные компоненты, которые можно использовать независимо или в сочетании с другими компонентами. В нашем случае - это каталог `modals`, эти компоненты будут подробнее описаны ниже
* Самые сложные для тестирования компоненты останутся в конце. Это каталог `hoc` и `fields` из папка `forms`. Как вам определить, какой из них следует тестировать первым? Я беру каталог, компоненты которого уже встречались в тестируемых компонентах. Например, компоненты из `hoc` каталога присутствовали в компоненте `widgets`, поэтому я уже знаю, где и с какой целью используется этот каталог и его компоненты
* Последняя папка `fields` содержит компоненты связанные с `redux-forms`

Окончательный порядок компонентов (на основе нашего примера) будет выглядеть следующим образом:

![](./images/img-3.png)

Следуя этому порядку, вы постепенно увеличиваете сложность тестируемых компонентов, таким образом, когда дело доходит до работы с более сложными компонентами, вы уже знаете, как ведут себя самые маленькие. Не берите для тестирования, например, поле «массив» если вы не знаете, как проверить поле «текст»; не берите компонент с использованием `redux-forms`, если вы не тестировали само поле «форма». Будьте последовательны в своем выборе, не берите первый компонент, который приходит в голову и включите логику. Конечно, структура вашего проекта может отличаться; он может иметь другие имена каталогов или содержать дополнительные компоненты, действия или редьюсеры, но логика определения порядка тестирования компонентов одинаковая.

### Давайте определим, что следует пропустить при тестировании:

1. **Сторонние библиотеки**. Не тестируйте функции, взятые из другой библиотеки; вы не несете ответственности за этот код. Пропустите его или имитируйте выполнение, если это нужно для тестирования вашего кода.
2. **Константы**. Название говорит само за себя. Они не изменчивы; это набор статического кода, который не предназначен для изменения.
3. **Встроенные стили** (если они используются в компоненте). Чтобы проверить встроенные стили, необходимо дублировать объект со стилями в тесте; если изменяется объект стилей, необходимо также изменить его в тесте. Не дублируйте код компонента в тестах, вы можете забыть изменить его в тестах. Более того, ваш коллега никогда не догадается о дублировании. В большинстве случаев встроенные стили не изменяют поведение компонента следовательно они не нуждаются в проверке. Возможно исключение, если ваши стили изменяются динамически.
4. **Вещи, не связанные с тестируемым компонентом**. Пропустите покрытие тестами компоненты которые были импортированны, будьте осторожны, если один компонент обернут в другой. В таком случае не тестируйте оболочку, анализируйте и тестируйте все отдельно.

Итак, как вы на самом деле пишете тесты? Я объединяю два подхода к тестированию:

* Тестирование при помощи снимков
* Тестирование логики компонентов

Тестирование при помощи снимков (Snapshot-тестирование) - полезный инструмент тестирования, если вы хотите быть уверенным, что пользовательский интерфейс не изменился. Когда вы впервые сталкиваетесь с этим инструментом тестирования, возникают вопросы, связанные с организацией и управлением снимками (snapshots). Принцип работы очень прост, но, к сожалению, он нигде подробно не описан; на официальном сайте [jestjs.io](https://jestjs.io/), очень плохо описана работа с тестирование при помощи снимков.

## Как тестировать при помощи снимков

**Шаг 1**. Напишите тест для компонента и в функции `expect` используйте метод `.toMatchSnapshot()`, который создаст вам снимок.

```js
it('render correctly text component', () => {  
    const TextInputComponent = renderer.create(<TextInput />).toJSON();
    expect(TextInputComponent).toMatchSnapshot();
});
```

**Шаг 2**. При первом запуске теста на одном уровне с тестом будет создан каталог с именем `__snapshots__` с автоматически созданным файлом с расширением `.snap` внутри.

Снимок выглядит так:

```js
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Render TextInput correctly component 1`] = `  
<input  
  className="input-custom"
  disabled={undefined}
  id={undefined}
  name={undefined}
  onBlur={undefined}
  onChange={[Function]}
  pattern={undefined}
  placeholder={undefined}
  readOnly={false}
  required={undefined}
  type="text"
  value={undefined}
/>
`;
```

**Шаг 3**. Отправьте снимок в репозиторий и сохраните его вместе с тестом.

Если компонент был изменен, то вам нужно обновить снимок с флагом `--updateSnapshot` или использовать короткий флаг `u`.

- - - -

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*